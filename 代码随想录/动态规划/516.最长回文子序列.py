# 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

# 示例 1: 输入: "bbbab" 输出: 4 一个可能的最长回文子序列为 "bbbb"。

# 示例 2: 输入:"cbbd" 输出: 2 一个可能的最长回文子序列为 "bb"。

# 提示：

# 1 <= s.length <= 1000
# s 只包含小写英文字母

class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
            n = len(s)
            dp = [[0] * n for _ in range(n)]

            # 初始化长度为1的回文子序列
            for i in range(n):
                dp[i][i] = 1

            # 动态规划过程
            for l in range(2, n + 1):
                for i in range(n - l + 1):
                    j = i + l - 1
                    if s[i] == s[j]:
                        dp[i][j] = dp[i + 1][j - 1] + 2 
                    else:
                        dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

            return dp[0][n - 1]  # 返回最长回文子序列的长度
    






















'''===================================== 笔记0620 ============================================='''
'''
最长公共子序列问题:0620
讲解笔记
https://www.bilibili.com/video/BV1AA411B7XV/?spm_id_from=333.337.search-card.all.click&vd_source=8f32c6c69c90af448f6be495aeb15c05

(1) 定义
经典LCS问题! boolean 布尔值 二维数组  定义dp[i][j]定义为字符串str的第i个字符和第j个字符是否是回文串
关键是找出状态方程,然后递归相加即可!一般是需要分解为若干个子问题,如下.
(2) 分解
[第一种情况]: 重点就是找到一个递推的关系!当某2个字符相等时,中间夹的字符(表示为dp[i + 1][j - 1])如果也相等,那么这一串就是回文子串了!
从最后一个情况看,往回推! S1的最后一个字符与S2的最后一个字符相等，那么只需要继续去求前面i-1和j-1字符串中的LCS长度即可 \
[第二种情况]:
S1的最后一个字符与S2的最后一个字符不相等，那么就要么把S1的末尾字符舍弃掉，要么把S2的末尾字符舍弃掉 \
问题就转换为求S1'和S2'的LCS长度,这里就取max即可!

(3) 子问题
初始,开头的字符串
'''

















